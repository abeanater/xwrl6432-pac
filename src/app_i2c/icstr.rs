#[doc = "Register `ICSTR` reader"]
pub type R = crate::R<IcstrSpec>;
#[doc = "Register `ICSTR` writer"]
pub type W = crate::W<IcstrSpec>;
#[doc = "Field `AL` reader - 0:0\\]
Arbitration-Lost interrupt flag bit. The Arbitration Lost flag bit is set to 1 when the device in the \"master\" mode senses it has lost an arbitration when two or more transmitters start a transmission almost simultaneously or when the I2C attempts to start a transfer while BB (bus busy) is 1. When this is set to 1 due to arbitration lost the MST/STT/STP bits are clear the I2C becomes a slave. Write '1' or Read the ICIVR (as 001) will clear it."]
pub type AlR = crate::BitReader;
#[doc = "Field `AL` writer - 0:0\\]
Arbitration-Lost interrupt flag bit. The Arbitration Lost flag bit is set to 1 when the device in the \"master\" mode senses it has lost an arbitration when two or more transmitters start a transmission almost simultaneously or when the I2C attempts to start a transfer while BB (bus busy) is 1. When this is set to 1 due to arbitration lost the MST/STT/STP bits are clear the I2C becomes a slave. Write '1' or Read the ICIVR (as 001) will clear it."]
pub type AlW<'a, REG> = crate::BitWriter<'a, REG>;
#[doc = "Field `NACK` reader - 1:1\\]
No-Acknowledgement interrupt flag bit. The No Acknowledge flag bit is set when the hardware in \"master\" mode detects no acknowledge has been received. This bit is NOT set by no-acknowledgement after Start byte Write '1' or Read the ICIVR (as 010) will clear it."]
pub type NackR = crate::BitReader;
#[doc = "Field `NACK` writer - 1:1\\]
No-Acknowledgement interrupt flag bit. The No Acknowledge flag bit is set when the hardware in \"master\" mode detects no acknowledge has been received. This bit is NOT set by no-acknowledgement after Start byte Write '1' or Read the ICIVR (as 010) will clear it."]
pub type NackW<'a, REG> = crate::BitWriter<'a, REG>;
#[doc = "Field `ARDY` reader - 2:2\\]
Register-access-ready interrupt flag bit. ARDY is generated by the hardware if the I2C is in the master mode when the previously programmed data and command has been performed and status bit has been updated. This flag is used by the CPU to let it knows that the I2C registers are ready to be accessed again. When RM=0 ARDY is set when the internal data count is passed 0 if STP register bit has not been set. When RM=1 ARDY is set at each byte end. If the I2C is in FDF mode(FDF=1) ARDY is set just after Start condition. This bit is automatically cleared by hardware when writing data to ICDXR in transmit mode reading data from ICDRR in receive mode or setting STT or STP bit. Write '1' will clear it."]
pub type ArdyR = crate::BitReader;
#[doc = "Field `ARDY` writer - 2:2\\]
Register-access-ready interrupt flag bit. ARDY is generated by the hardware if the I2C is in the master mode when the previously programmed data and command has been performed and status bit has been updated. This flag is used by the CPU to let it knows that the I2C registers are ready to be accessed again. When RM=0 ARDY is set when the internal data count is passed 0 if STP register bit has not been set. When RM=1 ARDY is set at each byte end. If the I2C is in FDF mode(FDF=1) ARDY is set just after Start condition. This bit is automatically cleared by hardware when writing data to ICDXR in transmit mode reading data from ICDRR in receive mode or setting STT or STP bit. Write '1' will clear it."]
pub type ArdyW<'a, REG> = crate::BitWriter<'a, REG>;
#[doc = "Field `ICRRDY` reader - 3:3\\]
Receive Data Ready interrupt flag bit. ICRRDY is set to\"1\" when the received data has been copied from ICRSR into the ICDRR. ICRRDY is cleared to\"0\" when the ICDRR is read. This bit can also be polled by the CPU to read the received data in the ICDRR. Write '1' or DRR Read will clear it."]
pub type IcrrdyR = crate::BitReader;
#[doc = "Field `ICRRDY` writer - 3:3\\]
Receive Data Ready interrupt flag bit. ICRRDY is set to\"1\" when the received data has been copied from ICRSR into the ICDRR. ICRRDY is cleared to\"0\" when the ICDRR is read. This bit can also be polled by the CPU to read the received data in the ICDRR. Write '1' or DRR Read will clear it."]
pub type IcrrdyW<'a, REG> = crate::BitWriter<'a, REG>;
#[doc = "Field `ICXRDY` reader - 4:4\\]
Transmit Data Ready interrupt flag bit. ICXRDY is set to\"1\" is generated when the transmitted data has been copied from ICDXR to the transmit-shift register (ICXSR). ICRXDY is clear to\"0\" when the ICDXR is written. This bit can also be polled by the CPU to write a new transmitted data into the ICDXR. Write '1' to this bit will set it and DXR Write will clear it."]
pub type IcxrdyR = crate::BitReader;
#[doc = "Field `ICXRDY` writer - 4:4\\]
Transmit Data Ready interrupt flag bit. ICXRDY is set to\"1\" is generated when the transmitted data has been copied from ICDXR to the transmit-shift register (ICXSR). ICRXDY is clear to\"0\" when the ICDXR is written. This bit can also be polled by the CPU to write a new transmitted data into the ICDXR. Write '1' to this bit will set it and DXR Write will clear it."]
pub type IcxrdyW<'a, REG> = crate::BitWriter<'a, REG>;
#[doc = "Field `SCD` reader - 5:5\\]
Stop Condition Detection bit SCD is set when the I2C sends or receives STOP condition. This bit is cleared by reading ICIVR (as 110) or writing '1' to itself."]
pub type ScdR = crate::BitReader;
#[doc = "Field `SCD` writer - 5:5\\]
Stop Condition Detection bit SCD is set when the I2C sends or receives STOP condition. This bit is cleared by reading ICIVR (as 110) or writing '1' to itself."]
pub type ScdW<'a, REG> = crate::BitWriter<'a, REG>;
#[doc = "Field `NU1` reader - 7:6\\]
Reserved"]
pub type Nu1R = crate::FieldReader;
#[doc = "Field `NU1` writer - 7:6\\]
Reserved"]
pub type Nu1W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
#[doc = "Field `AD0` reader - 8:8\\]
Address Zero Status: This bit is set to 1 by device if it detects the address of all (8) zeros (i.e. general call). The AD0 bit is reset to 0 (default value) when a\"start\" or\"stop\" condition is detected. - (RW )"]
pub type Ad0R = crate::BitReader;
#[doc = "Field `AD0` writer - 8:8\\]
Address Zero Status: This bit is set to 1 by device if it detects the address of all (8) zeros (i.e. general call). The AD0 bit is reset to 0 (default value) when a\"start\" or\"stop\" condition is detected. - (RW )"]
pub type Ad0W<'a, REG> = crate::BitWriter<'a, REG>;
#[doc = "Field `AAS` reader - 9:9\\]
Address As Slave. This bit is set to 1 by the device when it has recognized its own slave address or an address of all (8) zeros. The AAS bit is reset by stop condition or detection of any address byte that does not match ICOAR. - (RW )"]
pub type AasR = crate::BitReader;
#[doc = "Field `AAS` writer - 9:9\\]
Address As Slave. This bit is set to 1 by the device when it has recognized its own slave address or an address of all (8) zeros. The AAS bit is reset by stop condition or detection of any address byte that does not match ICOAR. - (RW )"]
pub type AasW<'a, REG> = crate::BitWriter<'a, REG>;
#[doc = "Field `XSMT` reader - 10:10\\]
Transmit shift empty not. This bit indicates whether the transmitter has experienced underflow. Underflow occurs when the transmit shift register (ICXSR) is empty and ICDXR has not been loaded. The FSM is holding for ICDXR write access. XSMT_ is cleared when underflow has occurred. XSMT_ is set to\"1\" as a result of writing to ICDXR. In repeat mode if the I2C in master transmitter mode is holding transfer with XSMT_=0 (i.e. waiting for further action) and the STT or STP bit is set XSMT_ is set to\"1\" by hardware."]
pub type XsmtR = crate::BitReader;
#[doc = "Field `XSMT` writer - 10:10\\]
Transmit shift empty not. This bit indicates whether the transmitter has experienced underflow. Underflow occurs when the transmit shift register (ICXSR) is empty and ICDXR has not been loaded. The FSM is holding for ICDXR write access. XSMT_ is cleared when underflow has occurred. XSMT_ is set to\"1\" as a result of writing to ICDXR. In repeat mode if the I2C in master transmitter mode is holding transfer with XSMT_=0 (i.e. waiting for further action) and the STT or STP bit is set XSMT_ is set to\"1\" by hardware."]
pub type XsmtW<'a, REG> = crate::BitWriter<'a, REG>;
#[doc = "Field `RSFULL` reader - 11:11\\]
Receive shift full. This bit indicates whether the receiver has experienced overrun. Overrun occurs when the receive shift register (ICRSR) is full and ICDRR has not been read since the ICRSR-to-ICDRR transfer. The FSM is holding for ICDRR read access. RSFULL is clear when reading the ICDRR. RSFULL is set to\"1\" when the I2C has recognized an overrun. The contents of ICDRR are NOT lost in this case. In repeat mode since double buffer (ICRSR and ICDRR) behaves like a single buffer RSFULL is set to\"1\" every time the data is received. RSFULL is clear as a result of reading the ICDRR. - (RW )"]
pub type RsfullR = crate::BitReader;
#[doc = "Field `RSFULL` writer - 11:11\\]
Receive shift full. This bit indicates whether the receiver has experienced overrun. Overrun occurs when the receive shift register (ICRSR) is full and ICDRR has not been read since the ICRSR-to-ICDRR transfer. The FSM is holding for ICDRR read access. RSFULL is clear when reading the ICDRR. RSFULL is set to\"1\" when the I2C has recognized an overrun. The contents of ICDRR are NOT lost in this case. In repeat mode since double buffer (ICRSR and ICDRR) behaves like a single buffer RSFULL is set to\"1\" every time the data is received. RSFULL is clear as a result of reading the ICDRR. - (RW )"]
pub type RsfullW<'a, REG> = crate::BitWriter<'a, REG>;
#[doc = "Field `BB` reader - 12:12\\]
Bus Busy. This bit indicates the state of the serial bus. BB=0: The bus is free. BB=1: The bus is occupied. On reception of a\"start\" condition the device sets BB to 1. This bit is also set if the I2C detects SCL low state. BB is clear to 0 after reception of a\"stop\" condition. BB is kept to\"0\" regardless SCL state when the I2C is in reset (IRS_=0). If the IRS_ is set to\"1\" during transaction between other I2C devices the BB bit is set at the first falling edge of SCL or START condition. - (RW )"]
pub type BbR = crate::BitReader;
#[doc = "Field `BB` writer - 12:12\\]
Bus Busy. This bit indicates the state of the serial bus. BB=0: The bus is free. BB=1: The bus is occupied. On reception of a\"start\" condition the device sets BB to 1. This bit is also set if the I2C detects SCL low state. BB is clear to 0 after reception of a\"stop\" condition. BB is kept to\"0\" regardless SCL state when the I2C is in reset (IRS_=0). If the IRS_ is set to\"1\" during transaction between other I2C devices the BB bit is set at the first falling edge of SCL or START condition. - (RW )"]
pub type BbW<'a, REG> = crate::BitWriter<'a, REG>;
#[doc = "Field `NACKSNT` reader - 13:13\\]
A No Acknowledge is sent due to NACKMOD is set to a\"1\". NACKSNT =0: A No Acknowledge is not sent. NACKSNT =1: A No Acknowledge is sent. Writing a\"1\" to this bit to clear it."]
pub type NacksntR = crate::BitReader;
#[doc = "Field `NACKSNT` writer - 13:13\\]
A No Acknowledge is sent due to NACKMOD is set to a\"1\". NACKSNT =0: A No Acknowledge is not sent. NACKSNT =1: A No Acknowledge is sent. Writing a\"1\" to this bit to clear it."]
pub type NacksntW<'a, REG> = crate::BitWriter<'a, REG>;
#[doc = "Field `SDIR` reader - 14:14\\]
Slave Direction. This bit is clear to '0' indicating the I2C is a master transmitter/receiver or a slave receiver. This bit is also clear by STOP condition or START condition. It is set to '1' when the I2C slave is a transmitter. In DLB mode (which the configuration should be master-transmitter slave-receiver) this bit is clear to '0'. Writing a\"1\" to this bit to clear it."]
pub type SdirR = crate::BitReader;
#[doc = "Field `SDIR` writer - 14:14\\]
Slave Direction. This bit is clear to '0' indicating the I2C is a master transmitter/receiver or a slave receiver. This bit is also clear by STOP condition or START condition. It is set to '1' when the I2C slave is a transmitter. In DLB mode (which the configuration should be master-transmitter slave-receiver) this bit is clear to '0'. Writing a\"1\" to this bit to clear it."]
pub type SdirW<'a, REG> = crate::BitWriter<'a, REG>;
#[doc = "Field `NU2` reader - 31:15\\]
Reserved"]
pub type Nu2R = crate::FieldReader<u32>;
#[doc = "Field `NU2` writer - 31:15\\]
Reserved"]
pub type Nu2W<'a, REG> = crate::FieldWriter<'a, REG, 17, u32>;
impl R {
    #[doc = "Bit 0 - 0:0\\]
Arbitration-Lost interrupt flag bit. The Arbitration Lost flag bit is set to 1 when the device in the \"master\" mode senses it has lost an arbitration when two or more transmitters start a transmission almost simultaneously or when the I2C attempts to start a transfer while BB (bus busy) is 1. When this is set to 1 due to arbitration lost the MST/STT/STP bits are clear the I2C becomes a slave. Write '1' or Read the ICIVR (as 001) will clear it."]
    #[inline(always)]
    pub fn al(&self) -> AlR {
        AlR::new((self.bits & 1) != 0)
    }
    #[doc = "Bit 1 - 1:1\\]
No-Acknowledgement interrupt flag bit. The No Acknowledge flag bit is set when the hardware in \"master\" mode detects no acknowledge has been received. This bit is NOT set by no-acknowledgement after Start byte Write '1' or Read the ICIVR (as 010) will clear it."]
    #[inline(always)]
    pub fn nack(&self) -> NackR {
        NackR::new(((self.bits >> 1) & 1) != 0)
    }
    #[doc = "Bit 2 - 2:2\\]
Register-access-ready interrupt flag bit. ARDY is generated by the hardware if the I2C is in the master mode when the previously programmed data and command has been performed and status bit has been updated. This flag is used by the CPU to let it knows that the I2C registers are ready to be accessed again. When RM=0 ARDY is set when the internal data count is passed 0 if STP register bit has not been set. When RM=1 ARDY is set at each byte end. If the I2C is in FDF mode(FDF=1) ARDY is set just after Start condition. This bit is automatically cleared by hardware when writing data to ICDXR in transmit mode reading data from ICDRR in receive mode or setting STT or STP bit. Write '1' will clear it."]
    #[inline(always)]
    pub fn ardy(&self) -> ArdyR {
        ArdyR::new(((self.bits >> 2) & 1) != 0)
    }
    #[doc = "Bit 3 - 3:3\\]
Receive Data Ready interrupt flag bit. ICRRDY is set to\"1\" when the received data has been copied from ICRSR into the ICDRR. ICRRDY is cleared to\"0\" when the ICDRR is read. This bit can also be polled by the CPU to read the received data in the ICDRR. Write '1' or DRR Read will clear it."]
    #[inline(always)]
    pub fn icrrdy(&self) -> IcrrdyR {
        IcrrdyR::new(((self.bits >> 3) & 1) != 0)
    }
    #[doc = "Bit 4 - 4:4\\]
Transmit Data Ready interrupt flag bit. ICXRDY is set to\"1\" is generated when the transmitted data has been copied from ICDXR to the transmit-shift register (ICXSR). ICRXDY is clear to\"0\" when the ICDXR is written. This bit can also be polled by the CPU to write a new transmitted data into the ICDXR. Write '1' to this bit will set it and DXR Write will clear it."]
    #[inline(always)]
    pub fn icxrdy(&self) -> IcxrdyR {
        IcxrdyR::new(((self.bits >> 4) & 1) != 0)
    }
    #[doc = "Bit 5 - 5:5\\]
Stop Condition Detection bit SCD is set when the I2C sends or receives STOP condition. This bit is cleared by reading ICIVR (as 110) or writing '1' to itself."]
    #[inline(always)]
    pub fn scd(&self) -> ScdR {
        ScdR::new(((self.bits >> 5) & 1) != 0)
    }
    #[doc = "Bits 6:7 - 7:6\\]
Reserved"]
    #[inline(always)]
    pub fn nu1(&self) -> Nu1R {
        Nu1R::new(((self.bits >> 6) & 3) as u8)
    }
    #[doc = "Bit 8 - 8:8\\]
Address Zero Status: This bit is set to 1 by device if it detects the address of all (8) zeros (i.e. general call). The AD0 bit is reset to 0 (default value) when a\"start\" or\"stop\" condition is detected. - (RW )"]
    #[inline(always)]
    pub fn ad0(&self) -> Ad0R {
        Ad0R::new(((self.bits >> 8) & 1) != 0)
    }
    #[doc = "Bit 9 - 9:9\\]
Address As Slave. This bit is set to 1 by the device when it has recognized its own slave address or an address of all (8) zeros. The AAS bit is reset by stop condition or detection of any address byte that does not match ICOAR. - (RW )"]
    #[inline(always)]
    pub fn aas(&self) -> AasR {
        AasR::new(((self.bits >> 9) & 1) != 0)
    }
    #[doc = "Bit 10 - 10:10\\]
Transmit shift empty not. This bit indicates whether the transmitter has experienced underflow. Underflow occurs when the transmit shift register (ICXSR) is empty and ICDXR has not been loaded. The FSM is holding for ICDXR write access. XSMT_ is cleared when underflow has occurred. XSMT_ is set to\"1\" as a result of writing to ICDXR. In repeat mode if the I2C in master transmitter mode is holding transfer with XSMT_=0 (i.e. waiting for further action) and the STT or STP bit is set XSMT_ is set to\"1\" by hardware."]
    #[inline(always)]
    pub fn xsmt(&self) -> XsmtR {
        XsmtR::new(((self.bits >> 10) & 1) != 0)
    }
    #[doc = "Bit 11 - 11:11\\]
Receive shift full. This bit indicates whether the receiver has experienced overrun. Overrun occurs when the receive shift register (ICRSR) is full and ICDRR has not been read since the ICRSR-to-ICDRR transfer. The FSM is holding for ICDRR read access. RSFULL is clear when reading the ICDRR. RSFULL is set to\"1\" when the I2C has recognized an overrun. The contents of ICDRR are NOT lost in this case. In repeat mode since double buffer (ICRSR and ICDRR) behaves like a single buffer RSFULL is set to\"1\" every time the data is received. RSFULL is clear as a result of reading the ICDRR. - (RW )"]
    #[inline(always)]
    pub fn rsfull(&self) -> RsfullR {
        RsfullR::new(((self.bits >> 11) & 1) != 0)
    }
    #[doc = "Bit 12 - 12:12\\]
Bus Busy. This bit indicates the state of the serial bus. BB=0: The bus is free. BB=1: The bus is occupied. On reception of a\"start\" condition the device sets BB to 1. This bit is also set if the I2C detects SCL low state. BB is clear to 0 after reception of a\"stop\" condition. BB is kept to\"0\" regardless SCL state when the I2C is in reset (IRS_=0). If the IRS_ is set to\"1\" during transaction between other I2C devices the BB bit is set at the first falling edge of SCL or START condition. - (RW )"]
    #[inline(always)]
    pub fn bb(&self) -> BbR {
        BbR::new(((self.bits >> 12) & 1) != 0)
    }
    #[doc = "Bit 13 - 13:13\\]
A No Acknowledge is sent due to NACKMOD is set to a\"1\". NACKSNT =0: A No Acknowledge is not sent. NACKSNT =1: A No Acknowledge is sent. Writing a\"1\" to this bit to clear it."]
    #[inline(always)]
    pub fn nacksnt(&self) -> NacksntR {
        NacksntR::new(((self.bits >> 13) & 1) != 0)
    }
    #[doc = "Bit 14 - 14:14\\]
Slave Direction. This bit is clear to '0' indicating the I2C is a master transmitter/receiver or a slave receiver. This bit is also clear by STOP condition or START condition. It is set to '1' when the I2C slave is a transmitter. In DLB mode (which the configuration should be master-transmitter slave-receiver) this bit is clear to '0'. Writing a\"1\" to this bit to clear it."]
    #[inline(always)]
    pub fn sdir(&self) -> SdirR {
        SdirR::new(((self.bits >> 14) & 1) != 0)
    }
    #[doc = "Bits 15:31 - 31:15\\]
Reserved"]
    #[inline(always)]
    pub fn nu2(&self) -> Nu2R {
        Nu2R::new((self.bits >> 15) & 0x0001_ffff)
    }
}
impl W {
    #[doc = "Bit 0 - 0:0\\]
Arbitration-Lost interrupt flag bit. The Arbitration Lost flag bit is set to 1 when the device in the \"master\" mode senses it has lost an arbitration when two or more transmitters start a transmission almost simultaneously or when the I2C attempts to start a transfer while BB (bus busy) is 1. When this is set to 1 due to arbitration lost the MST/STT/STP bits are clear the I2C becomes a slave. Write '1' or Read the ICIVR (as 001) will clear it."]
    #[inline(always)]
    #[must_use]
    pub fn al(&mut self) -> AlW<IcstrSpec> {
        AlW::new(self, 0)
    }
    #[doc = "Bit 1 - 1:1\\]
No-Acknowledgement interrupt flag bit. The No Acknowledge flag bit is set when the hardware in \"master\" mode detects no acknowledge has been received. This bit is NOT set by no-acknowledgement after Start byte Write '1' or Read the ICIVR (as 010) will clear it."]
    #[inline(always)]
    #[must_use]
    pub fn nack(&mut self) -> NackW<IcstrSpec> {
        NackW::new(self, 1)
    }
    #[doc = "Bit 2 - 2:2\\]
Register-access-ready interrupt flag bit. ARDY is generated by the hardware if the I2C is in the master mode when the previously programmed data and command has been performed and status bit has been updated. This flag is used by the CPU to let it knows that the I2C registers are ready to be accessed again. When RM=0 ARDY is set when the internal data count is passed 0 if STP register bit has not been set. When RM=1 ARDY is set at each byte end. If the I2C is in FDF mode(FDF=1) ARDY is set just after Start condition. This bit is automatically cleared by hardware when writing data to ICDXR in transmit mode reading data from ICDRR in receive mode or setting STT or STP bit. Write '1' will clear it."]
    #[inline(always)]
    #[must_use]
    pub fn ardy(&mut self) -> ArdyW<IcstrSpec> {
        ArdyW::new(self, 2)
    }
    #[doc = "Bit 3 - 3:3\\]
Receive Data Ready interrupt flag bit. ICRRDY is set to\"1\" when the received data has been copied from ICRSR into the ICDRR. ICRRDY is cleared to\"0\" when the ICDRR is read. This bit can also be polled by the CPU to read the received data in the ICDRR. Write '1' or DRR Read will clear it."]
    #[inline(always)]
    #[must_use]
    pub fn icrrdy(&mut self) -> IcrrdyW<IcstrSpec> {
        IcrrdyW::new(self, 3)
    }
    #[doc = "Bit 4 - 4:4\\]
Transmit Data Ready interrupt flag bit. ICXRDY is set to\"1\" is generated when the transmitted data has been copied from ICDXR to the transmit-shift register (ICXSR). ICRXDY is clear to\"0\" when the ICDXR is written. This bit can also be polled by the CPU to write a new transmitted data into the ICDXR. Write '1' to this bit will set it and DXR Write will clear it."]
    #[inline(always)]
    #[must_use]
    pub fn icxrdy(&mut self) -> IcxrdyW<IcstrSpec> {
        IcxrdyW::new(self, 4)
    }
    #[doc = "Bit 5 - 5:5\\]
Stop Condition Detection bit SCD is set when the I2C sends or receives STOP condition. This bit is cleared by reading ICIVR (as 110) or writing '1' to itself."]
    #[inline(always)]
    #[must_use]
    pub fn scd(&mut self) -> ScdW<IcstrSpec> {
        ScdW::new(self, 5)
    }
    #[doc = "Bits 6:7 - 7:6\\]
Reserved"]
    #[inline(always)]
    #[must_use]
    pub fn nu1(&mut self) -> Nu1W<IcstrSpec> {
        Nu1W::new(self, 6)
    }
    #[doc = "Bit 8 - 8:8\\]
Address Zero Status: This bit is set to 1 by device if it detects the address of all (8) zeros (i.e. general call). The AD0 bit is reset to 0 (default value) when a\"start\" or\"stop\" condition is detected. - (RW )"]
    #[inline(always)]
    #[must_use]
    pub fn ad0(&mut self) -> Ad0W<IcstrSpec> {
        Ad0W::new(self, 8)
    }
    #[doc = "Bit 9 - 9:9\\]
Address As Slave. This bit is set to 1 by the device when it has recognized its own slave address or an address of all (8) zeros. The AAS bit is reset by stop condition or detection of any address byte that does not match ICOAR. - (RW )"]
    #[inline(always)]
    #[must_use]
    pub fn aas(&mut self) -> AasW<IcstrSpec> {
        AasW::new(self, 9)
    }
    #[doc = "Bit 10 - 10:10\\]
Transmit shift empty not. This bit indicates whether the transmitter has experienced underflow. Underflow occurs when the transmit shift register (ICXSR) is empty and ICDXR has not been loaded. The FSM is holding for ICDXR write access. XSMT_ is cleared when underflow has occurred. XSMT_ is set to\"1\" as a result of writing to ICDXR. In repeat mode if the I2C in master transmitter mode is holding transfer with XSMT_=0 (i.e. waiting for further action) and the STT or STP bit is set XSMT_ is set to\"1\" by hardware."]
    #[inline(always)]
    #[must_use]
    pub fn xsmt(&mut self) -> XsmtW<IcstrSpec> {
        XsmtW::new(self, 10)
    }
    #[doc = "Bit 11 - 11:11\\]
Receive shift full. This bit indicates whether the receiver has experienced overrun. Overrun occurs when the receive shift register (ICRSR) is full and ICDRR has not been read since the ICRSR-to-ICDRR transfer. The FSM is holding for ICDRR read access. RSFULL is clear when reading the ICDRR. RSFULL is set to\"1\" when the I2C has recognized an overrun. The contents of ICDRR are NOT lost in this case. In repeat mode since double buffer (ICRSR and ICDRR) behaves like a single buffer RSFULL is set to\"1\" every time the data is received. RSFULL is clear as a result of reading the ICDRR. - (RW )"]
    #[inline(always)]
    #[must_use]
    pub fn rsfull(&mut self) -> RsfullW<IcstrSpec> {
        RsfullW::new(self, 11)
    }
    #[doc = "Bit 12 - 12:12\\]
Bus Busy. This bit indicates the state of the serial bus. BB=0: The bus is free. BB=1: The bus is occupied. On reception of a\"start\" condition the device sets BB to 1. This bit is also set if the I2C detects SCL low state. BB is clear to 0 after reception of a\"stop\" condition. BB is kept to\"0\" regardless SCL state when the I2C is in reset (IRS_=0). If the IRS_ is set to\"1\" during transaction between other I2C devices the BB bit is set at the first falling edge of SCL or START condition. - (RW )"]
    #[inline(always)]
    #[must_use]
    pub fn bb(&mut self) -> BbW<IcstrSpec> {
        BbW::new(self, 12)
    }
    #[doc = "Bit 13 - 13:13\\]
A No Acknowledge is sent due to NACKMOD is set to a\"1\". NACKSNT =0: A No Acknowledge is not sent. NACKSNT =1: A No Acknowledge is sent. Writing a\"1\" to this bit to clear it."]
    #[inline(always)]
    #[must_use]
    pub fn nacksnt(&mut self) -> NacksntW<IcstrSpec> {
        NacksntW::new(self, 13)
    }
    #[doc = "Bit 14 - 14:14\\]
Slave Direction. This bit is clear to '0' indicating the I2C is a master transmitter/receiver or a slave receiver. This bit is also clear by STOP condition or START condition. It is set to '1' when the I2C slave is a transmitter. In DLB mode (which the configuration should be master-transmitter slave-receiver) this bit is clear to '0'. Writing a\"1\" to this bit to clear it."]
    #[inline(always)]
    #[must_use]
    pub fn sdir(&mut self) -> SdirW<IcstrSpec> {
        SdirW::new(self, 14)
    }
    #[doc = "Bits 15:31 - 31:15\\]
Reserved"]
    #[inline(always)]
    #[must_use]
    pub fn nu2(&mut self) -> Nu2W<IcstrSpec> {
        Nu2W::new(self, 15)
    }
}
#[doc = "I2C Interrupt Status register\n\nYou can [`read`](crate::Reg::read) this register and get [`icstr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`icstr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct IcstrSpec;
impl crate::RegisterSpec for IcstrSpec {
    type Ux = u32;
}
#[doc = "`read()` method returns [`icstr::R`](R) reader structure"]
impl crate::Readable for IcstrSpec {}
#[doc = "`write(|w| ..)` method takes [`icstr::W`](W) writer structure"]
impl crate::Writable for IcstrSpec {
    type Safety = crate::Unsafe;
    const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
    const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
}
#[doc = "`reset()` method sets ICSTR to value 0"]
impl crate::Resettable for IcstrSpec {
    const RESET_VALUE: u32 = 0;
}
