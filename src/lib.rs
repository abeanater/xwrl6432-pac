#![doc = "Peripheral access API for IWRL6432 microcontrollers (generated using svd2rust v0.33.4 ( ))\n\nYou can find an overview of the generated API [here].\n\nAPI features to be included in the [next]
svd2rust release can be generated by cloning the svd2rust [repository], checking out the above commit, and running `cargo doc --open`.\n\n[here]: https://docs.rs/svd2rust/0.33.4/svd2rust/#peripheral-api\n[next]: https://github.com/rust-embedded/svd2rust/blob/master/CHANGELOG.md#unreleased\n[repository]: https://github.com/rust-embedded/svd2rust"]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![no_std]
use core::marker::PhantomData;
use core::ops::Deref;
#[doc = r"Number available in the NVIC for configuring priority"]
pub const NVIC_PRIO_BITS: u8 = 3;
#[allow(unused_imports)]
use generic::*;
#[doc = r"Common register and bit access and modify traits"]
pub mod generic;
#[cfg(feature = "rt")]
extern "C" {}
#[doc(hidden)]
#[repr(C)]
pub union Vector {
    _handler: unsafe extern "C" fn(),
    _reserved: u32,
}
#[cfg(feature = "rt")]
#[doc(hidden)]
#[link_section = ".vector_table.interrupts"]
#[no_mangle]
pub static __INTERRUPTS: [Vector; 0] = [];
#[doc = r"Enumeration of all the interrupts."]
#[derive(Copy, Clone, Debug, PartialEq, Eq)]
pub enum Interrupt {}
unsafe impl cortex_m::interrupt::InterruptNumber for Interrupt {
    #[inline(always)]
    fn number(self) -> u16 {
        match self {}
    }
}
#[doc = "GPADC_CTRL"]
pub struct GpadcCtrl {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for GpadcCtrl {}
impl GpadcCtrl {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gpadc_ctrl::RegisterBlock = 0x50f7_fc00 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gpadc_ctrl::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for GpadcCtrl {
    type Target = gpadc_ctrl::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for GpadcCtrl {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GpadcCtrl").finish()
    }
}
#[doc = "GPADC_CTRL"]
pub mod gpadc_ctrl;
#[doc = "APP_LIN"]
pub struct AppLin {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for AppLin {}
impl AppLin {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const app_lin::RegisterBlock = 0x5300_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const app_lin::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for AppLin {
    type Target = app_lin::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for AppLin {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("AppLin").finish()
    }
}
#[doc = "APP_LIN"]
pub mod app_lin;
#[doc = "APP_UART"]
pub struct AppUart0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for AppUart0 {}
impl AppUart0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const app_uart_0::RegisterBlock = 0x53f7_f000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const app_uart_0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for AppUart0 {
    type Target = app_uart_0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for AppUart0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("AppUart0").finish()
    }
}
#[doc = "APP_UART"]
pub mod app_uart_0;
#[doc = "APP_SPI"]
pub struct AppSpi0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for AppSpi0 {}
impl AppSpi0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const app_spi_0::RegisterBlock = 0x53f7_f400 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const app_spi_0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for AppSpi0 {
    type Target = app_spi_0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for AppSpi0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("AppSpi0").finish()
    }
}
#[doc = "APP_SPI"]
pub mod app_spi_0;
#[doc = "APP_CANCFG"]
pub struct AppCancfg {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for AppCancfg {}
impl AppCancfg {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const app_cancfg::RegisterBlock = 0x53f7_f800 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const app_cancfg::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for AppCancfg {
    type Target = app_cancfg::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for AppCancfg {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("AppCancfg").finish()
    }
}
#[doc = "APP_CANCFG"]
pub mod app_cancfg;
#[doc = "APP_CANECC"]
pub struct AppCanecc {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for AppCanecc {}
impl AppCanecc {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const app_canecc::RegisterBlock = 0x53f7_fc00 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const app_canecc::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for AppCanecc {
    type Target = app_canecc::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for AppCanecc {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("AppCanecc").finish()
    }
}
#[doc = "APP_CANECC"]
pub mod app_canecc;
#[doc = "Register test environment"]
pub struct TptcA0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TptcA0 {}
impl TptcA0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const tptc_a0::RegisterBlock = 0x5400_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const tptc_a0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for TptcA0 {
    type Target = tptc_a0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for TptcA0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("TptcA0").finish()
    }
}
#[doc = "Register test environment"]
pub mod tptc_a0;
#[doc = "Register test environment"]
pub struct TptcA1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TptcA1 {}
impl TptcA1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const tptc_a1::RegisterBlock = 0x5401_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const tptc_a1::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for TptcA1 {
    type Target = tptc_a1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for TptcA1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("TptcA1").finish()
    }
}
#[doc = "Register test environment"]
pub mod tptc_a1;
#[doc = "APP_CRC"]
pub struct AppCrc {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for AppCrc {}
impl AppCrc {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const app_crc::RegisterBlock = 0x5402_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const app_crc::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for AppCrc {
    type Target = app_crc::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for AppCrc {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("AppCrc").finish()
    }
}
#[doc = "APP_CRC"]
pub mod app_crc;
#[doc = "HWA_CFG"]
pub struct HwaCfg {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for HwaCfg {}
impl HwaCfg {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const hwa_cfg::RegisterBlock = 0x5501_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const hwa_cfg::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for HwaCfg {
    type Target = hwa_cfg::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for HwaCfg {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("HwaCfg").finish()
    }
}
#[doc = "HWA_CFG"]
pub mod hwa_cfg;
#[doc = "Register test environment"]
pub struct TptcB0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TptcB0 {}
impl TptcB0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const tptc_b0::RegisterBlock = 0x5502_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const tptc_b0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for TptcB0 {
    type Target = tptc_b0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for TptcB0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("TptcB0").finish()
    }
}
#[doc = "Register test environment"]
pub mod tptc_b0;
#[doc = "Register test environment"]
pub struct TptcB0_1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TptcB0_1 {}
impl TptcB0_1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const tptc_b0_1::RegisterBlock = 0x5504_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const tptc_b0_1::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for TptcB0_1 {
    type Target = tptc_b0_1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for TptcB0_1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("TptcB0_1").finish()
    }
}
#[doc = "Register test environment"]
pub mod tptc_b0_1;
#[doc = "TPCC"]
pub struct TpccB {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TpccB {}
impl TpccB {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const tpcc_b::RegisterBlock = 0x5508_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const tpcc_b::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for TpccB {
    type Target = tpcc_b::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for TpccB {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("TpccB").finish()
    }
}
#[doc = "TPCC"]
pub mod tpcc_b;
#[doc = "TPCC"]
pub struct TpccA {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TpccA {}
impl TpccA {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const tpcc_a::RegisterBlock = 0x5600_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const tpcc_a::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for TpccA {
    type Target = tpcc_a::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for TpccA {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("TpccA").finish()
    }
}
#[doc = "TPCC"]
pub mod tpcc_a;
#[doc = "APP_RCM"]
pub struct AppRcm {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for AppRcm {}
impl AppRcm {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const app_rcm::RegisterBlock = 0x5604_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const app_rcm::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for AppRcm {
    type Target = app_rcm::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for AppRcm {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("AppRcm").finish()
    }
}
#[doc = "APP_RCM"]
pub mod app_rcm;
#[doc = "APP_CTRL"]
pub struct AppCtrl {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for AppCtrl {}
impl AppCtrl {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const app_ctrl::RegisterBlock = 0x5606_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const app_ctrl::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for AppCtrl {
    type Target = app_ctrl::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for AppCtrl {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("AppCtrl").finish()
    }
}
#[doc = "APP_CTRL"]
pub mod app_ctrl;
#[doc = "APP_HWA_ADCBUF_CTRL"]
pub struct AppHwaAdcbufCtrl {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for AppHwaAdcbufCtrl {}
impl AppHwaAdcbufCtrl {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const app_hwa_adcbuf_ctrl::RegisterBlock = 0x5608_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const app_hwa_adcbuf_ctrl::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for AppHwaAdcbufCtrl {
    type Target = app_hwa_adcbuf_ctrl::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for AppHwaAdcbufCtrl {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("AppHwaAdcbufCtrl").finish()
    }
}
#[doc = "APP_HWA_ADCBUF_CTRL"]
pub mod app_hwa_adcbuf_ctrl;
#[doc = "APP_ECC_AGG"]
pub struct AppEccAgg {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for AppEccAgg {}
impl AppEccAgg {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const app_ecc_agg::RegisterBlock = 0x56f7_ec00 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const app_ecc_agg::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for AppEccAgg {
    type Target = app_ecc_agg::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for AppEccAgg {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("AppEccAgg").finish()
    }
}
#[doc = "APP_ECC_AGG"]
pub mod app_ecc_agg;
#[doc = "APP_RTI"]
pub struct AppRti {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for AppRti {}
impl AppRti {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const app_rti::RegisterBlock = 0x56f7_f000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const app_rti::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for AppRti {
    type Target = app_rti::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for AppRti {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("AppRti").finish()
    }
}
#[doc = "APP_RTI"]
pub mod app_rti;
#[doc = "APP_WD"]
pub struct AppWd {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for AppWd {}
impl AppWd {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const app_wd::RegisterBlock = 0x56f7_f400 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const app_wd::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for AppWd {
    type Target = app_wd::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for AppWd {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("AppWd").finish()
    }
}
#[doc = "APP_WD"]
pub mod app_wd;
#[doc = "APP_DCC"]
pub struct AppDcc {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for AppDcc {}
impl AppDcc {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const app_dcc::RegisterBlock = 0x56f7_f800 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const app_dcc::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for AppDcc {
    type Target = app_dcc::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for AppDcc {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("AppDcc").finish()
    }
}
#[doc = "APP_DCC"]
pub mod app_dcc;
#[doc = "APP_ESM"]
pub struct AppEsm {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for AppEsm {}
impl AppEsm {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const app_esm::RegisterBlock = 0x56f7_fc00 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const app_esm::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for AppEsm {
    type Target = app_esm::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for AppEsm {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("AppEsm").finish()
    }
}
#[doc = "APP_ESM"]
pub mod app_esm;
#[doc = "APP_UART"]
pub struct AppUart1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for AppUart1 {}
impl AppUart1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const app_uart_1::RegisterBlock = 0x57f7_f000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const app_uart_1::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for AppUart1 {
    type Target = app_uart_1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for AppUart1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("AppUart1").finish()
    }
}
#[doc = "APP_UART"]
pub mod app_uart_1;
#[doc = "APP_SPI"]
pub struct AppSpi1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for AppSpi1 {}
impl AppSpi1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const app_spi_1::RegisterBlock = 0x57f7_f400 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const app_spi_1::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for AppSpi1 {
    type Target = app_spi_1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for AppSpi1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("AppSpi1").finish()
    }
}
#[doc = "APP_SPI"]
pub mod app_spi_1;
#[doc = "APP_I2C"]
pub struct AppI2c {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for AppI2c {}
impl AppI2c {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const app_i2c::RegisterBlock = 0x57f7_f800 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const app_i2c::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for AppI2c {
    type Target = app_i2c::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for AppI2c {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("AppI2c").finish()
    }
}
#[doc = "APP_I2C"]
pub mod app_i2c;
#[doc = "APP_PWM"]
pub struct AppPwm {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for AppPwm {}
impl AppPwm {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const app_pwm::RegisterBlock = 0x57f7_fc00 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const app_pwm::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for AppPwm {
    type Target = app_pwm::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for AppPwm {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("AppPwm").finish()
    }
}
#[doc = "APP_PWM"]
pub mod app_pwm;
#[doc = "TOP_IO_MUX"]
pub struct TopIoMux {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TopIoMux {}
impl TopIoMux {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const top_io_mux::RegisterBlock = 0x5a00_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const top_io_mux::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for TopIoMux {
    type Target = top_io_mux::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for TopIoMux {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("TopIoMux").finish()
    }
}
#[doc = "TOP_IO_MUX"]
pub mod top_io_mux;
#[doc = "APP_PRCM"]
pub struct AppPrcm {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for AppPrcm {}
impl AppPrcm {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const app_prcm::RegisterBlock = 0x5a04_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const app_prcm::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for AppPrcm {
    type Target = app_prcm::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for AppPrcm {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("AppPrcm").finish()
    }
}
#[doc = "APP_PRCM"]
pub mod app_prcm;
#[doc = "TOP_GIO"]
pub struct TopGio {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TopGio {}
impl TopGio {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const top_gio::RegisterBlock = 0x5af7_fc00 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const top_gio::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for TopGio {
    type Target = top_gio::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for TopGio {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("TopGio").finish()
    }
}
#[doc = "TOP_GIO"]
pub mod top_gio;
#[doc = "TOPSS_CTRL"]
pub struct TopssCtrl {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TopssCtrl {}
impl TopssCtrl {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const topss_ctrl::RegisterBlock = 0x5b02_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const topss_ctrl::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for TopssCtrl {
    type Target = topss_ctrl::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for TopssCtrl {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("TopssCtrl").finish()
    }
}
#[doc = "TOPSS_CTRL"]
pub mod topss_ctrl;
#[doc = "PLLDIG_CTRL"]
pub struct PlldigCtrl {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PlldigCtrl {}
impl PlldigCtrl {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const plldig_ctrl::RegisterBlock = 0x5b04_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const plldig_ctrl::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for PlldigCtrl {
    type Target = plldig_ctrl::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PlldigCtrl {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PlldigCtrl").finish()
    }
}
#[doc = "PLLDIG_CTRL"]
pub mod plldig_ctrl;
#[doc = "PBIST"]
pub struct Pbist {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Pbist {}
impl Pbist {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pbist::RegisterBlock = 0x5c02_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pbist::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Pbist {
    type Target = pbist::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Pbist {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pbist").finish()
    }
}
#[doc = "PBIST"]
pub mod pbist;
#[doc = "TOP_DEBUGSS"]
pub struct TopDebugss {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TopDebugss {}
impl TopDebugss {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const top_debugss::RegisterBlock = 0x5ca0_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const top_debugss::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for TopDebugss {
    type Target = top_debugss::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for TopDebugss {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("TopDebugss").finish()
    }
}
#[doc = "TOP_DEBUGSS"]
pub mod top_debugss;
#[doc = "APP_CFG_QSPI"]
pub struct AppCfgQspi {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for AppCfgQspi {}
impl AppCfgQspi {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const app_cfg_qspi::RegisterBlock = 0x7800_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const app_cfg_qspi::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for AppCfgQspi {
    type Target = app_cfg_qspi::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for AppCfgQspi {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("AppCfgQspi").finish()
    }
}
#[doc = "APP_CFG_QSPI"]
pub mod app_cfg_qspi;
#[no_mangle]
static mut DEVICE_PERIPHERALS: bool = false;
#[doc = r" All the peripherals."]
#[allow(non_snake_case)]
pub struct Peripherals {
    #[doc = "GPADC_CTRL"]
    pub gpadc_ctrl: GpadcCtrl,
    #[doc = "APP_LIN"]
    pub app_lin: AppLin,
    #[doc = "APP_UART_0"]
    pub app_uart_0: AppUart0,
    #[doc = "APP_SPI_0"]
    pub app_spi_0: AppSpi0,
    #[doc = "APP_CANCFG"]
    pub app_cancfg: AppCancfg,
    #[doc = "APP_CANECC"]
    pub app_canecc: AppCanecc,
    #[doc = "TPTC_A0"]
    pub tptc_a0: TptcA0,
    #[doc = "TPTC_A1"]
    pub tptc_a1: TptcA1,
    #[doc = "APP_CRC"]
    pub app_crc: AppCrc,
    #[doc = "HWA_CFG"]
    pub hwa_cfg: HwaCfg,
    #[doc = "TPTC_B0"]
    pub tptc_b0: TptcB0,
    #[doc = "TPTC_B0_1"]
    pub tptc_b0_1: TptcB0_1,
    #[doc = "TPCC_B"]
    pub tpcc_b: TpccB,
    #[doc = "TPCC_A"]
    pub tpcc_a: TpccA,
    #[doc = "APP_RCM"]
    pub app_rcm: AppRcm,
    #[doc = "APP_CTRL"]
    pub app_ctrl: AppCtrl,
    #[doc = "APP_HWA_ADCBUF_CTRL"]
    pub app_hwa_adcbuf_ctrl: AppHwaAdcbufCtrl,
    #[doc = "APP_ECC_AGG"]
    pub app_ecc_agg: AppEccAgg,
    #[doc = "APP_RTI"]
    pub app_rti: AppRti,
    #[doc = "APP_WD"]
    pub app_wd: AppWd,
    #[doc = "APP_DCC"]
    pub app_dcc: AppDcc,
    #[doc = "APP_ESM"]
    pub app_esm: AppEsm,
    #[doc = "APP_UART_1"]
    pub app_uart_1: AppUart1,
    #[doc = "APP_SPI_1"]
    pub app_spi_1: AppSpi1,
    #[doc = "APP_I2C"]
    pub app_i2c: AppI2c,
    #[doc = "APP_PWM"]
    pub app_pwm: AppPwm,
    #[doc = "TOP_IO_MUX"]
    pub top_io_mux: TopIoMux,
    #[doc = "APP_PRCM"]
    pub app_prcm: AppPrcm,
    #[doc = "TOP_GIO"]
    pub top_gio: TopGio,
    #[doc = "TOPSS_CTRL"]
    pub topss_ctrl: TopssCtrl,
    #[doc = "PLLDIG_CTRL"]
    pub plldig_ctrl: PlldigCtrl,
    #[doc = "PBIST"]
    pub pbist: Pbist,
    #[doc = "TOP_DEBUGSS"]
    pub top_debugss: TopDebugss,
    #[doc = "APP_CFG_QSPI"]
    pub app_cfg_qspi: AppCfgQspi,
}
impl Peripherals {
    #[doc = r" Returns all the peripherals *once*."]
    #[cfg(feature = "critical-section")]
    #[inline]
    pub fn take() -> Option<Self> {
        critical_section::with(|_| {
            if unsafe { DEVICE_PERIPHERALS } {
                return None;
            }
            Some(unsafe { Peripherals::steal() })
        })
    }
    #[doc = r" Unchecked version of `Peripherals::take`."]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Each of the returned peripherals must be used at most once."]
    #[inline]
    pub unsafe fn steal() -> Self {
        DEVICE_PERIPHERALS = true;
        Peripherals {
            gpadc_ctrl: GpadcCtrl::steal(),
            app_lin: AppLin::steal(),
            app_uart_0: AppUart0::steal(),
            app_spi_0: AppSpi0::steal(),
            app_cancfg: AppCancfg::steal(),
            app_canecc: AppCanecc::steal(),
            tptc_a0: TptcA0::steal(),
            tptc_a1: TptcA1::steal(),
            app_crc: AppCrc::steal(),
            hwa_cfg: HwaCfg::steal(),
            tptc_b0: TptcB0::steal(),
            tptc_b0_1: TptcB0_1::steal(),
            tpcc_b: TpccB::steal(),
            tpcc_a: TpccA::steal(),
            app_rcm: AppRcm::steal(),
            app_ctrl: AppCtrl::steal(),
            app_hwa_adcbuf_ctrl: AppHwaAdcbufCtrl::steal(),
            app_ecc_agg: AppEccAgg::steal(),
            app_rti: AppRti::steal(),
            app_wd: AppWd::steal(),
            app_dcc: AppDcc::steal(),
            app_esm: AppEsm::steal(),
            app_uart_1: AppUart1::steal(),
            app_spi_1: AppSpi1::steal(),
            app_i2c: AppI2c::steal(),
            app_pwm: AppPwm::steal(),
            top_io_mux: TopIoMux::steal(),
            app_prcm: AppPrcm::steal(),
            top_gio: TopGio::steal(),
            topss_ctrl: TopssCtrl::steal(),
            plldig_ctrl: PlldigCtrl::steal(),
            pbist: Pbist::steal(),
            top_debugss: TopDebugss::steal(),
            app_cfg_qspi: AppCfgQspi::steal(),
        }
    }
}
